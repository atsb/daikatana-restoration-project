///////////////////////////////////////////////////////////////////////////////
//	Surface Sprites
//
//	Routines for managing surface sprites
//
//	Animation:	frames of a surface sprite are stored in sprite->skins
//
//	Nelno, 9/14/98
///////////////////////////////////////////////////////////////////////////////
#include	"r_local.h"

#include "dk_point.h"
#include "dk_array.h"

#include	"r_surfSprite.h"
//#include	"r_protex.h"

///////////////////////////////////////////////////////////////////////////////
//	globals
///////////////////////////////////////////////////////////////////////////////

short			g_numSurfSprites;
short			g_oldestSprite;
surfSprite_t	g_surfSpriteList [MAX_SURF_SPRITES];

model_t			*g_testSprite;

float			surfSprite_transform[3][4];

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Next
//
//	returns the surfSprite pointed to surfSprite->nextIndex
///////////////////////////////////////////////////////////////////////////////

surfSprite_t *surfSprite_Next (surfSprite_t *sprite)
{
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Oldest
//
//	returns the oldest surfaceSprite in the list
///////////////////////////////////////////////////////////////////////////////

surfSprite_t *surfSprite_Oldest (void)
{
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Allocate
//
//	returns a free surfSprite from g_surfSpriteList or NULL if there are no
//	free sprites.  Also increments g_numSurfSprites.
///////////////////////////////////////////////////////////////////////////////

surfSprite_t *surfSprite_Allocate (void)
{
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Free
//
//	free's the passed surfSprite 
///////////////////////////////////////////////////////////////////////////////

void surfSprite_Free (surfSprite_t *sprite)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Init
//
//	Initialize the entire list of surfSprites
///////////////////////////////////////////////////////////////////////////////

void surfSprite_Init (void)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_PolyCenter
//
//	returns the averaged center of the passed poly
///////////////////////////////////////////////////////////////////////////////

void surfSprite_PolyCenter (glpoly_t *poly, vec3_t center)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_PolyNormal
//
//	get the normal of a poly based on the first three vertices in it
///////////////////////////////////////////////////////////////////////////////

void surfSprite_PolyNormal (glpoly_t *poly, vec3_t normal)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Add
//
//	adds a surface sprite to the passed surface
///////////////////////////////////////////////////////////////////////////////

void surfSprite_Add (msurface_t *surf, surfSprite_t *sprite)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_Remove
//
//	Removes a surface sprite from the passed surface and frees it.
///////////////////////////////////////////////////////////////////////////////

void surfSprite_Remove (msurface_t *surf, surfSprite_t *sprite)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_DrawSprite
//
//	draws a single sprite oriented to a surface
///////////////////////////////////////////////////////////////////////////////

void VecToAngles (vec3_t in, vec3_t angles)
{
	float	forward;
	float	yaw, pitch;
	
	if (in [YAW] == 0 && in [PITCH] == 0)
	{
		yaw = 0;
		if (in [ROLL] > 0)
			pitch = 90;
		else
			pitch = 270;
	}
	else
	{
		yaw = (int) (atan2 (in [YAW], in [PITCH]) * 180 / M_PI);
		if (yaw < 0)
			yaw += 360;

		forward = sqrt (in [PITCH] * in [PITCH] + in [YAW] * in [YAW]);
		pitch = (int) (atan2 (in [ROLL], forward) * 180 / M_PI);
		
		if (pitch < 0)
			pitch += 360;
	}

	angles [PITCH] = -pitch;
	angles [YAW] = yaw;
	angles [ROLL] = 0;
}

extern	void R_DrawSpriteModel (entity_t *e);

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_AddSurfaceBeam
//
//	adds beams of light to a surface sprite
///////////////////////////////////////////////////////////////////////////////

void surfSprite_AddSurfaceBeam (msurface_t *surf, surfSprite_t *sprite, vec3_t normal)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_DrawSpritePolys
//
///////////////////////////////////////////////////////////////////////////////

void surfSprite_DrawSpritePolys (vec3_t origin, vec3_t angles, vec3_t lightValue, model_t *model, int frame, float alpha, float scale)
{
}

void surfSprite_DrawSprite (msurface_t *surf, surfSprite_t *sprite)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_DrawSpritesForSurface
//
//	Draws all the surface sprite linked to the passed surface
//
//	NOTE:	assumes that surf->surfSpriteIndex is valid!  Should be checked
//			before calling this routine!
//	FIXME:	make sure this works correctly with non-multitexture cards!
///////////////////////////////////////////////////////////////////////////////

void surfSprite_DrawSpritesForSurface (msurface_t *surf, int isAlphaSurface)
{
}


///////////////////////////////////////////////////////////////////////////////
//	hr_SetUpTransform
//
//	set up the transformation matrix for passed values
//
//	r_origin == view_org, will this cause a lag problem if we do this
//	inbetween frames?  Or will one frame of lag be unoticeable anyway...
//
//	maybe turning off lerping for hierarchical models makes more sense...
//	we may not be able to get valid lerp info since we're calling these
//	routines at a different point than when the model is being drawn...
//	but then, that's only when we're doing hr stuff from the server side.
///////////////////////////////////////////////////////////////////////////////

void surfSprite_SetUpTransform (vec3_t origin, vec3_t angles)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_TransformVector
//
///////////////////////////////////////////////////////////////////////////////

void surfSprite_TransformVector (vec3_t in, vec3_t out)
{
}

///////////////////////////////////////////////////////////////////////////////
//	surfSprite_TransformedPolyCenter
//
//	returns the averaged center of the passed poly
///////////////////////////////////////////////////////////////////////////////

void surfSprite_TransformedPolyCenter (glpoly_t *poly, vec3_t center)
{
}

///////////////////////////////////////////////////////////////////////////////
//	GL_AddSurfaceSprite
//
//	Called from the client.  Adds a model to the correct surface in a plane
///////////////////////////////////////////////////////////////////////////////

void surfSprite_AddSurfaceSprite (CVector &origin, CVector &entityOrigin, 
		CVector &entityAngles, void *hitModel, int planeIndex, void *model, 
		int frame, float roll, float scale, byte flags)
{
}

